<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>èŠ±å¾¡é…ç½®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v15.3</title>
  <style>
    :root{
      --gap:10px;
      --tile:92px;
      --tileH:70px;
      --bd:#d8d8d8;
      --muted:#6a6a6a;
      --shadow: 0 1px 2px rgba(0,0,0,.06);

      --bg:#ffffff;
      --page:#f4f6f8;
      --text:#111;
      --control:#ffffff;
      --control2:#f3f4f6;
      --control3:#e9edf3;
      --board:#f6f7f8;
      --tileEmpty:#eef2f3;

      --flower:#ffd46a;
      --flower2:#ffefb6;

      --slot:#d7f0d7;
      --slotP:#93eef2;
      --slotOff:#e6e6e6;

      /* Attribute colors */
      --c-ç­‹åŠ›:#ff6a6a; /* red */
      --c-å™¨ç”¨:#4edc76; /* green */
      --c-ä½“è³ª:#ffb24a; /* orange */
      --c-çŸ¥æµ:#68d7ff; /* light blue */
      --c-ç²¾ç¥:#b37cff; /* purple */

      --badgeText:#111;

      /* Flower level badge color (changed from green to neutral dark) */
      --badgeLvlBg:#ffffff;
      --badgeLvlText:#111111;
    }

    
html{ -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
html[data-theme="dark"]{
      --bg:#0f1217;
      --page:#0b0d10;
      --board:#151a21;
      --tileEmpty:#11151b;
      --bd:rgba(255,255,255,.14);
      --muted:rgba(255,255,255,.62);
      --shadow: 0 10px 30px rgba(0,0,0,.38);
      --text:rgba(255,255,255,.92);
      --badgeText:#0b0d10;
      --badgeLvlBg:rgba(255,255,255,.92);
      --badgeLvlText:#0b0d10;
    
      --control: rgba(255,255,255,.07);
      --control2: rgba(255,255,255,.12);
      --chipbg: rgba(255,255,255,.08);
}
    

    body{ font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif; margin:0; padding:12px; color:var(--text); line-height:1.35; background:var(--page); overflow-x:auto; }
    h1{ font-size:20px; margin:0 0 6px; }
    .muted{ color:var(--muted); font-size:12px; }
    .wrap{ display:grid; gap:var(--gap); grid-template-columns:1fr; }
    .wrap > *{ min-width:0; }
    .spanAll{ grid-column: 1 / -1; }
    @media(min-width:1150px){ .wrap{ grid-template-columns: 420px minmax(0,1fr); align-items:start; } }
    .card{ background:var(--bg); border:1px solid var(--bd); border-radius:14px; padding:12px; box-shadow:var(--shadow); }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border:1px solid var(--bd); border-radius:999px; font-size:12px; background:#fff;}
    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
    select,input{ padding:6px 8px; border-radius:12px; border:1px solid var(--bd); background:var(--control); color:var(--text); }
    input[type="number"]{ width:92px; }
    button{ padding:10px 12px; border-radius:999px; border:1px solid var(--bd); background:var(--control2); color:var(--text); font-size:14px; font-weight:700; cursor:pointer; box-shadow:0 1px 0 rgba(0,0,0,.03); }
    button.primary{ border-color:var(--bd); background:#f3f3f3; font-weight:700; }
    button:active{ transform: translateY(1px); }
    .btns{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }

    .two{ display:grid; grid-template-columns: 1fr; gap:14px; }
    .two > *{ min-width:0; }
    @media(min-width:1150px){ .two{ grid-template-columns: 1.1fr 0.9fr; } }

    .boardWrap{ overflow-x:auto; overflow-y:hidden; width:100%; max-width:100%; min-width:0; }
    
  /* Mobile/iOS: allow rows to grow with native select height (prevents overlap) */
  .board{ grid-auto-rows: auto; }
  .tile{ min-height: var(--tileH); }
  .boardWrap{ -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
.board{
      display:grid;
      grid-template-columns: repeat(9, var(--tile));
      grid-auto-rows: var(--tileH);
      gap: 8px;
      padding: 8px;
      background:var(--board);
      border:1px solid #eee;
      border-radius:16px;
    }
    .tile{
      border:1px solid var(--bd);
      border-radius:14px;
      padding:6px;
      background:var(--tileEmpty);
      box-shadow: 0 1px 1px rgba(0,0,0,.04);
      display:flex;
      flex-direction:column;
      gap:4px;
      justify-content:space-between;
      min-width: var(--tile);
      position:relative;
    }
    .tile.flower{ background: linear-gradient(180deg, var(--flower), var(--flower2)); }
    .tile.l{ background: var(--slot); }
    .tile.p{ background: var(--slotP); }
    .tile.off{ background: var(--slotOff); opacity:.65; }

    .idline{ font-weight:800; font-size:12px; color:var(--text); display:flex; justify-content:space-between; gap:6px; align-items:center;}
    .idline small{ font-weight:700; color:var(--muted); }

    .tile select{ width:100%; font-size: 10.5px; padding:4px 6px; border-radius:12px; background:var(--control); color:var(--text); }
    .tile .sub select{ width:auto; min-width:66px; max-width:74px; }
    .tile .sub .mini{ font-size:10px; white-space:nowrap; }
    .sub{ font-size:11px; color:var(--muted); display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
html[data-theme="dark"] .tile .sub{ color: rgba(0,0,0,.55); }
    .mini{ font-size:10px; color:var(--muted); }

    /* Dark theme: tiles are light, so make meta text darker for contrast */
    html[data-theme="dark"] .tile .mini,
    html[data-theme="dark"] .tile .sub,
    html[data-theme="dark"] .tile .idline small{
      color: rgba(0,0,0,.58);
    }

    /* flower skill badges (dynamic attribute colors) */
    .badge{
      position:absolute;
      top:6px; left:6px;
      display:flex; gap:4px;
      align-items:center;
      z-index:3;
    }
    .sq{
      width:22px; height:18px;
      border-radius:6px;
      display:flex; align-items:center; justify-content:center;
      font-size:11px; font-weight:900;
      color:var(--badgeText);
      box-shadow: 0 1px 1px rgba(0,0,0,.12);
      border:1px solid color-mix(in srgb, var(--bd) 70%, transparent);
      background:var(--control);
    }
    .sq.attr-ç­‹åŠ›{ background: var(--c-ç­‹åŠ›); color:#fff;}
    .sq.attr-å™¨ç”¨{ background: var(--c-å™¨ç”¨); }
    .sq.attr-ä½“è³ª{ background: var(--c-ä½“è³ª); }
    .sq.attr-çŸ¥æµ{ background: var(--c-çŸ¥æµ); }
    .sq.attr-ç²¾ç¥{ background: var(--c-ç²¾ç¥); color:#fff;}

    /* Flower level badge (color changed) */
    .lvl{
      position:absolute;
      top:6px; right:6px;
      width: 22px; height: 22px;
      border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      font-size:10px; font-weight:900;
      color:var(--badgeLvlText);
      background: var(--badgeLvlBg);
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 1px 1px rgba(0,0,0,.10);
      z-index:3;
    }
    .lvl span{ transform: translateY(-.5px); }
    .lvl .lvtxt{ font-size:9px; opacity:.9; margin-right:2px; }

    /* Rune badge (circle) at top-right in rune tiles */
    .rbadge{
      position:absolute;
      top:6px; right:6px;
      width:24px; height:24px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 1px 1px rgba(0,0,0,.10);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:9px;
      line-height:1.0;
      text-align:center;
      color:#111;
      background:var(--control);
      z-index:2;
      overflow:hidden;
    }
    .rbadge .t{ display:flex; flex-direction:column; gap:1px; transform: translateY(-.5px); }
    .rbadge .t span{ display:block; }
    .rbadge.single.attr-ç­‹åŠ›{ background: var(--c-ç­‹åŠ›); color:#fff;}
    .rbadge.single.attr-å™¨ç”¨{ background: var(--c-å™¨ç”¨); }
    .rbadge.single.attr-ä½“è³ª{ background: var(--c-ä½“è³ª); }
    .rbadge.single.attr-çŸ¥æµ{ background: var(--c-çŸ¥æµ); }
    .rbadge.single.attr-ç²¾ç¥{ background: var(--c-ç²¾ç¥); color:#fff;}
    .rbadge.double{ color:#111; }

    .kpi{ display:grid; grid-template-columns: 160px 1fr; gap:8px; font-size:13px; }
    .kpi div:nth-child(odd){ color:#444; }
    .log{ white-space:pre-wrap; font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:14px; padding:10px; max-height:260px; overflow:auto; }

    table{ border-collapse:collapse; width:100%; font-size:12px; }
    th,td{ border:1px solid #ddd; padding:6px; text-align:left; }
    th{ background:#f5f5f5; }

    .ok{ color:#0a7; font-weight:900; }
    .ng{ color:#d33; font-weight:900; }
    .warn{ color:#d80; font-weight:900; }
    .small{ font-size:11px; color:var(--muted); }
    .hint{ background: #fffdf0; border:1px solid #f0e1a4; padding:8px; border-radius:12px; font-size:12px; }

    .legend{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; border:1px solid #ddd; background:#fff; font-size:12px;}
    .dot{ width:12px; height:12px; border-radius:4px; display:inline-block; border:1px solid rgba(0,0,0,.08); }
    .dot.attr-ç­‹åŠ›{ background: var(--c-ç­‹åŠ›); }
    .dot.attr-å™¨ç”¨{ background: var(--c-å™¨ç”¨); }
    .dot.attr-ä½“è³ª{ background: var(--c-ä½“è³ª); }
    .dot.attr-çŸ¥æµ{ background: var(--c-çŸ¥æµ); }
    .dot.attr-ç²¾ç¥{ background: var(--c-ç²¾ç¥); }
  
    .fcard{
      border:1px solid #e3e3e3;
      border-radius:16px;
      background:#fff;
      padding:10px 10px 8px;
      box-shadow: 0 1px 2px rgba(0,0,0,.05);
    }
    .fcardHead{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin-bottom:6px;
    }
    .fcardTitle{
      font-weight:900;
      font-size:13px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #e1e1e1;
      background:#fafafa;
      font-size:11px;
      font-weight:800;
      color:#333;
    }
    .tag.lv{ background:#fff; }
    .fgrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
    }
    .skillBox{
      border:1px solid #ededed;
      border-radius:14px;
      padding:8px;
      background:#fbfbfb;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      align-items:center;
    }
    .skillName{
      font-weight:900;
      font-size:12px;
    }
    .skillMeta{
      font-size:11px;
      color:#555;
      margin-top:2px;
    }
    .skillLv{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
      min-width:86px;
    }
    .skillLv .big{
      font-size:18px;
      font-weight:1000;
      line-height:1;
    }
    .skillLv .next{
      font-size:11px;
    }

  
    /* Hide optional right panels (keep inventory status only) */
    .optPanel{ display:none !important; }

  
    .tableWrap{ overflow:auto; max-width:100%; }
    .nowrap{ white-space:nowrap; }

    /* Table border consistency */
    table{ border-collapse:collapse; }
    th,td{ border:1px solid var(--bd); }
    th{ background:#fafafa; }
    th.splitL, td.splitL{ border-left:3px solid #b0b0b0 !important; }

    /* Cost table: keep compact */
    .costWrap{ max-width:420px; margin:0 auto; }
    .costWrap table{ width:auto !important; }
    .costTable{ width:auto; }

    #enforceInvWrap{ display:none !important; }
  
    .mlAuto{ margin-left:auto; }
    .ghost{ background:transparent; border:1px solid var(--bd); }
    .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.18); display:flex; justify-content:flex-end; align-items:flex-start; padding:14px; z-index:999; }
    .overlay.hidden{ display:none; }
    .drawerCard{ width:320px; max-width:calc(100vw - 28px); max-height:calc(100vh - 28px); overflow:auto; background:var(--bg); border:1px solid var(--bd); border-radius:14px; padding:12px; box-shadow:var(--shadow); }


    /* ---- UI polish (v15.3 UI+) ---- */
    .page{ max-width:1520px; margin:0 auto; }
    /* Top KPI bar: treat as read-only status (different from form controls) */
    .topbar{
      position:sticky; top:10px; z-index:50;
      display:flex; flex-wrap:wrap; gap:12px; align-items:center;
      padding:10px 12px;
      border:1px solid color-mix(in srgb, var(--bd) 70%, transparent);
      border-radius:16px;
      background: color-mix(in srgb, var(--bg) 92%, transparent);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      margin: 10px 0 12px;
    }
    .kpiGroup{
      display:flex; align-items:baseline; gap:8px;
      padding:2px 0;
      border:none;
      background:transparent;
    }
    .kpiLabel{ font-size:11px; color:var(--muted); letter-spacing:.02em; }
    .kpiValue{ font-size:14px; font-weight:900; }
    .kpiValue.statusOK{ color:#0a7; }
    .kpiValue.statusWarn{ color:#d80; }
    .kpiValue.statusNG{ color:#b00020; }

    .statusTag{
      font-size:11px; font-weight:900;
      color:var(--muted);
      padding:4px 10px;
      border-radius:999px;
      border:1px dashed color-mix(in srgb, var(--bd) 70%, transparent);
      background: color-mix(in srgb, var(--bg) 70%, var(--board));
      user-select:none;
      pointer-events:none;
    }
    .kpiGroup{ cursor:default; user-select:none; pointer-events:none; }

    button{ transition: transform .06s ease, background .15s ease, border-color .15s ease; }
    button:hover{ background:var(--control2); }
    button.primary{ background:var(--control2); font-weight:700; }
    html[data-theme="dark"] button:hover{ background: rgba(255,255,255,.08); }
    html[data-theme="dark"] button.primary{ background: rgba(255,255,255,.12); }

    .card{ background:var(--bg); }
    .pill, .chip{ background:var(--control); }
    html[data-theme="dark"] .pill, html[data-theme="dark"] .chip{ background:rgba(255,255,255,.08); }
    html[data-theme="dark"] th{ background: rgba(255,255,255,.07); }
    html[data-theme="dark"] table, html[data-theme="dark"] th, html[data-theme="dark"] td{ border-color: rgba(255,255,255,.12); }

    .wrap{ padding-bottom: 6px; }
    /* Main layout: controls + board */
    @media(min-width:1150px){
      .wrap{ grid-template-columns: 420px minmax(0,1fr); }
    }

    /* Board + side panel inside the board card */
    .boardGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
      align-items:start;
    }
    @media(min-width:1150px){
      .boardGrid{ grid-template-columns: minmax(0,1fr) 320px; }
    }
    .sidePanel{
      border:1px solid color-mix(in srgb, var(--bd) 70%, transparent);
      border-radius:16px;
      padding:10px;
      background: color-mix(in srgb, var(--bg) 94%, transparent);
    }
    .sidePanel .pill{ margin-bottom:8px; }
    .sidePanel table{ font-size:12px; }

    .flash{
      animation: flash 1.1s ease;
    }
    @keyframes flash{
      0%{ box-shadow: 0 0 0 0 rgba(104,215,255,.0); }
      30%{ box-shadow: 0 0 0 6px rgba(104,215,255,.22); }
      100%{ box-shadow: 0 0 0 0 rgba(104,215,255,.0); }
    }

    /* Make the board card feel more "app-like" */
    .boardWrap{ border-radius:16px; }
    .board{ border-color: color-mix(in srgb, var(--bd) 55%, transparent); }

    /* Right side: tighter remain table */
    .themeCtl{
      display:flex;
      align-items:center;
      gap:10px;
      margin-left:auto;
    }
    .themeBtn{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--bd);
      background:var(--bg);
      font-weight:800;
    }
    .themeBtn .mini{ font-size:11px; color:var(--muted); }
    .themeBtn .val{ font-size:12px; }
    .themeBtn .icon{ font-size:14px; }

    /* Detail table grouping for Skill1/Skill2 */
    .detailGroup th{
      background: color-mix(in srgb, #f5f5f5 80%, var(--bg));
      text-align:center;
      font-weight:900;
    }
    html[data-theme="dark"] .detailGroup th{
      background: rgba(255,255,255,.08);
    }
    th.grp1{ border-right:3px solid #b0b0b0 !important; }
    td.grp1{ border-right:3px solid #b0b0b0 !important; }


  
  /* Layout: make board use full width (move remain panel to left card) */
  .boardGrid{ display:block; }
  .remainPanelLeft{ margin-top:10px; padding-top:10px; border-top:1px solid var(--bd); }
  .remainPanelLeft .tableWrap{ max-height:260px; overflow:auto; }
  .remainPanelLeft table{ width:100%; border-collapse:separate; border-spacing:0; }

  /* Inventory table readability */
  #invTable th, #invTable td{ white-space:nowrap; }
  #invTable th:nth-child(1), #invTable td:nth-child(1){ min-width:140px; }
  #invTable th:nth-child(4), #invTable td:nth-child(4){ min-width:64px; text-align:center; }
  #invTable th:nth-child(6), #invTable td:nth-child(6){ min-width:64px; text-align:center; }
  #invTable input[type="number"]{ width:90px; }

  /* Tile text should stay readable on pastel backgrounds in both themes */
  .tile{ color:var(--tileText); }
  .tile .idline{ color:rgba(0,0,0,.55); }
  .tile select{ background:rgba(255,255,255,.92); color:var(--tileText); border-color:rgba(0,0,0,.18); }
  .tile .sub{ color:var(--tileMuted); }

  /* Flower name (full) */
  .fname{
    margin-top:4px;
    padding:4px 8px;
    border-radius:10px;
    background:rgba(255,255,255,.70);
    border:1px solid rgba(0,0,0,.10);
    font-size:12px;
    font-weight:800;
    line-height:1.25;
    white-space:normal;
    word-break:break-word;
  }

  
      .fname-inline{
        flex:1;
        min-width:0;
        font-size:11px;
        font-weight:800;
        line-height:1.1;
        padding:3px 8px;
        border-radius:999px;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
        background: rgba(255,255,255,.55);
        border:1px solid rgba(0,0,0,.12);
        color:#0a0d14;
       display:none!important; pointer-events:none; }
      .flower-sub{ gap:6px; }
      .flower-sub select{ width:64px; }
      [data-theme="dark"] .fname-inline{ background: rgba(255,255,255,.55); border-color: rgba(0,0,0,.12); color:#0a0d14; }
/* Flower Lv controls: make them pop */
  .lvRow{
    margin-top:6px;
    padding:6px 8px;
    border-radius:12px;
    background:rgba(0,0,0,.05);
    border:1px solid rgba(0,0,0,.08);
  }
  .lvRow .lbl{ font-size:11px; font-weight:800; color:rgba(0,0,0,.55); }
  .lvRow select{ background:rgba(255,255,255,.92); }

  /* Button weight consistency */
  button{ font-weight:700; }
  button.primary{ font-weight:900; }

  /* Dark theme: improve contrast for form controls + tables */
  [data-theme="dark"] .card{ background:rgba(255,255,255,0.06); }
  [data-theme="dark"] input, 
  [data-theme="dark"] select{
    background:rgba(255,255,255,0.08);
    border-color:rgba(255,255,255,0.18);
    color:var(--text);
  }

  [data-theme="dark"] .tile select{ background: rgba(255,255,255,.92); color:#0a0d14; border-color: rgba(0,0,0,.15); }
  [data-theme="dark"] .tableWrap table{ background:transparent; }
  [data-theme="dark"] th, [data-theme="dark"] td{ border-color:rgba(255,255,255,0.14); }
  [data-theme="dark"] .muted{ color:rgba(255,255,255,0.70); }

  /* Keep tiles readable even in dark theme */
  [data-theme="dark"] .tile{ box-shadow:0 10px 30px rgba(0,0,0,.40); }
  [data-theme="dark"] .tile .idline{ color:rgba(0,0,0,.55); } /* tile stays light */
  [data-theme="dark"] .lvRow{ background:rgba(255,255,255,.55); border-color:rgba(0,0,0,.08); }
  [data-theme="dark"] .lvRow .lbl{ color:rgba(0,0,0,.55); }


@media (max-width: 520px){
  :root{
    --gap: 8px;
    --tile: 86px;
    --tileH: 92px;
  }
  .tile .idline{ font-size: 14px; }
  .tile select, .tile .lv{ font-size: 13px; }
  .tile .suck{ font-size: 12px; }
}

</style>
</head>
<body>
  <div class="page">
  <h1>èŠ±å¾¡é…ç½®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v15.3</h1>
  <div class="topbar">
      <span class="statusTag">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</span>
    <div class="kpiGroup">
      <span class="kpiLabel">ç·Cost</span>
      <span class="kpiValue" id="kpiTotalCost">0</span>
    </div>
    <div class="kpiGroup">
      <span class="kpiLabel">ãƒ¢ãƒ¼ãƒ‰</span>
      <span class="kpiValue" id="kpiMode">-</span>
    </div>
    <div class="kpiGroup">
      <span class="kpiLabel">è·</span>
      <span class="kpiValue" id="kpiJob">-</span>
    </div>
    <div class="kpiGroup" id="kpiInvGroup" style="display:none;">
      <span class="kpiLabel">åœ¨åº«è¶…é</span>
      <span class="kpiValue statusNG" id="kpiInvStatus">è¶…éã‚ã‚Š</span>
    </div>

    <div class="themeCtl" aria-label="ãƒ†ãƒ¼ãƒåˆ‡æ›¿">
      <button id="themeToggle" type="button" class="themeBtn" title="ãƒ†ãƒ¼ãƒåˆ‡æ›¿">
        <span class="mini">ãƒ†ãƒ¼ãƒ</span>
        <span class="val" id="themeLabel">ãƒ©ã‚¤ãƒˆ</span>
        <span class="icon" aria-hidden="true">ğŸŒ“</span>
      </button>
    </div>
  </div>
  <div class="wrap" style="margin-top:14px;">
    <div class="card">
      <div class="row">
        <label>ãƒ¢ãƒ¼ãƒ‰
          <select id="modeSel">
            <option value="free">è‡ªç”±è¨­è¨ˆ</option>
            <option value="inv">æ‰‹æŒã¡éœŠéŸ»ã®ã¿</option>
          </select>
        </label>
        <label>è·ã‚¿ã‚¤ãƒ—
          <select id="jobType">
            <option value="phys">ç‰©ç†è·</option>
            <option value="mag">é­”æ³•è·</option>
          </select>
        </label>
        
      </div>

      <div class="legend">
        <span class="chip"><span class="dot attr-ç­‹åŠ›"></span>ç­‹åŠ›</span>
        <span class="chip"><span class="dot attr-å™¨ç”¨"></span>å™¨ç”¨</span>
        <span class="chip"><span class="dot attr-ä½“è³ª"></span>ä½“è³ª</span>
        <span class="chip"><span class="dot attr-çŸ¥æµ"></span>çŸ¥æµ</span>
        <span class="chip"><span class="dot attr-ç²¾ç¥"></span>ç²¾ç¥</span>
      </div>
      <div class="small muted" style="margin-top:6px;">
        è·ã‚¿ã‚¤ãƒ—ã§éœŠéŸ»å€™è£œã‚’è‡ªå‹•ãƒ•ã‚£ãƒ«ã‚¿ï¼šç‰©ç†ï¼ç­‹åŠ›/å™¨ç”¨/ä½“è³ªã€é­”æ³•ï¼çŸ¥æµ/ç²¾ç¥/ä½“è³ª
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="btnInvToggle" type="button" class="ghost" title="ã‚¯ãƒªãƒƒã‚¯ã§é–‹é–‰" aria-expanded="false">éœŠéŸ»ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼ˆé–‹ãï¼‰</button>
        <label class="pill" id="enforceInvWrap"><input id="enforceInv" type="checkbox" /> åœ¨åº«åˆ¶é™ã‚’æœ‰åŠ¹åŒ–</label>
      </div>
      <div id="invSection" style="margin-top:10px; display:none;">
      <div class="row" style="margin-top:10px; align-items:flex-end; flex-wrap:wrap; gap:10px;">
                <label>ç¨®åˆ¥
          <select id="addKind">
            <option value="single">ã‚·ãƒ³ã‚°ãƒ«</option>
            <option value="double">ãƒ€ãƒ–ãƒ«</option>
          </select>
        </label>
        <label>å±æ€§1
          <select id="addA1"></select>
        </label>
        <label id="addA2Wrap">å±æ€§2
          <select id="addA2"></select>
        </label>
        <label>Rank
          <select id="addRank">
            <option value="1">R1</option>
            <option value="2">R2</option>
          </select>
        </label>
        <label>å¼·åŒ–
          <select id="addEnh">
            <option value="7">+7</option>
            <option value="8">+8</option>
            <option value="9">+9</option>
          </select>
        </label>
        <label>å€‹æ•°
          <input id="addQty" type="number" min="1" step="1" value="1" style="width:90px"/>
        </label>
        <button id="btnAddInv" class="primary">ä¸€è¦§ã«è¿½åŠ </button>
      </div>

        <div class="tableWrap" style="margin-top:10px;">
          <table id="invTable">
          <thead>
            <tr><th>å±æ€§</th><th>Rank</th><th>å¼·åŒ–</th><th>ç¨®åˆ¥</th><th>å€‹æ•°</th><th>å‰Šé™¤</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        </div>
      </div>

        <div class="btns">
          <button id="btnExport">æ§‹æˆã‚’JSONä¿å­˜</button>
          <button id="btnImport" class="primary">JSONèª­ã¿è¾¼ã¿</button>
        </div>
      

      <div style="margin-top:12px;">
        <div class="btns">
          <button id="btnClearRunes">éœŠéŸ»ã ã‘ã‚¯ãƒªã‚¢</button>
          <button id="btnClearFlowers">èŠ±å¾¡ã ã‘ã‚¯ãƒªã‚¢</button>
          <button id="btnResetAll" class="primary">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="remainPanelLeft">
                  <div class="row" style="margin-bottom:6px;">
                    <span class="pill">éœŠéŸ»æ®‹æ•°</span>
                  </div>
                  <div class="small muted" id="remainSideNote">â€»ã€Œæ‰‹æŒã¡éœŠéŸ»ã®ã¿ã€ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æ›´æ–°</div>
                  <div class="tableWrap" style="margin-top:8px;">
                    <table>
                      <thead>
                        <tr><th>éœŠéŸ»</th><th>æ‰€æŒ</th><th>ä½¿ç”¨</th><th>æ®‹</th></tr>
                      </thead>
                      <tbody id="remainTBodySide"></tbody>
                    </table>
                  </div>
        </div>
      </div>

    </div>

    <div class="card">
      <div class="boardGrid">
        <div>
          <div class="row">
            <span class="pill">F=èŠ±å¾¡ / L=å˜ä½“éœŠéŸ» / P=å…±æœ‰éœŠéŸ»</span>
          </div>
          <div class="boardWrap" style="margin-top:10px;">
            <div class="board" id="board"></div>
          </div>
        </div>
</div>
    </div>

    <div class="card spanAll" style="margin-top:14px;">
      <div class="row">
        <span class="pill">èŠ±å¾¡ã®è©³ç´°</span>
        
      </div>

      <div class="tableWrap" style="margin-top:10px;">
        <table>
          <thead>
            <tr class="detailGroup">
              <th class="nowrap" rowspan="2">æ </th>
              <th class="nowrap" rowspan="2">èŠ±å¾¡å</th>
              <th colspan="4" class="grp1">ã‚¹ã‚­ãƒ«1</th>
              <th colspan="4">ã‚¹ã‚­ãƒ«2</th>
              <th class="nowrap" rowspan="2">ç´¯è¨ˆCost</th>
            </tr>
            <tr>
              <th class="nowrap">åå‰</th>
              <th class="nowrap">Lv</th>
              <th class="nowrap">ç´¯è¨ˆå±æ€§å€¤</th>
              <th class="nowrap grp1">æ¬¡ã®Lvã¾ã§</th>
              <th class="nowrap">åå‰</th>
              <th class="nowrap">Lv</th>
              <th class="nowrap">ç´¯è¨ˆå±æ€§å€¤</th>
              <th class="nowrap">æ¬¡ã®Lvã¾ã§</th>
            </tr>
          </thead>
          <tbody id="detailTBody"></tbody>
          <tfoot>
            <tr>
              <th colspan="10" style="text-align:right;">ç·Costï¼ˆç›¤é¢åˆè¨ˆï¼šå…±æœ‰ã¯1å›ã®ã¿ï¼‰</th>
              <th id="totalCostUnique">0</th>
            </tr>
          </tfoot>
        </table>
      </div>

      <div class="small" style="margin-top:8px;">
        â€»ã€Œç´¯è¨ˆCostã€ã¯ã€ãã®èŠ±å¾¡ã«å½±éŸ¿ã™ã‚‹éœŠéŸ»ã‚¹ãƒ­ãƒƒãƒˆã®ç´¯è¨ˆã§ã™ï¼ˆå…±æœ‰ã‚¹ãƒ­ãƒƒãƒˆã‚‚èŠ±å¾¡ã”ã¨ã«åŠ ç®—ï¼‰ã€‚<br/>
        â€»ã€Œç·Costã€ã¯ç›¤é¢å…¨ä½“ã®åˆè¨ˆï¼ˆå…±æœ‰ã‚¹ãƒ­ãƒƒãƒˆã¯1å›ã®ã¿ï¼‰ã§ã™ã€‚
      </div>

      
    </div>

  </div>

  </div>

<script>
const FLOWERS = [
  {name:"ç¶¿ã®é¢¨éˆ´", rank:1,   phys:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"å™¨ç”¨", s2:"å¦¨å®³", a2:"ç­‹åŠ›"}, mag:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"çŸ¥æµ", s2:"å¦¨å®³", a2:"ç²¾ç¥"}},
  {name:"ç†±æƒ…ã®ã‚³ã‚³ãƒŠãƒƒãƒ„", rank:1, phys:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"ç­‹åŠ›", s2:"å¦¨å®³", a2:"ä½“è³ª"}, mag:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"çŸ¥æµ", s2:"å¦¨å®³", a2:"ä½“è³ª"}},
  {name:"ãƒ›ãƒ¯ã‚¤ãƒˆãƒãƒ³ãƒãƒ³", rank:2, phys:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"å™¨ç”¨", s2:"å¦¨å®³", a2:"ç­‹åŠ›"}, mag:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"çŸ¥æµ", s2:"å¦¨å®³", a2:"ç²¾ç¥"}},
  {name:"ç´«éœ²æœå®Ÿ", rank:2, phys:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"ä½“è³ª", s2:"å¦¨å®³", a2:"ç­‹åŠ›"}, mag:{s1:"ä¼šå¿ƒãƒ€ãƒ¡ãƒ¼ã‚¸", a1:"ä½“è³ª", s2:"å¦¨å®³", a2:"çŸ¥æµ"}},
  {name:"ç”˜ã€…ã‚µã‚¯ãƒ©", rank:1, phys:{s1:"ç–¾èµ°", a1:"å™¨ç”¨", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"ç­‹åŠ›"}, mag:{s1:"ç–¾èµ°", a1:"ç²¾ç¥", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"çŸ¥æµ"}},
  {name:"ã†ã¨ã†ã¨ç¡è“®", rank:2, phys:{s1:"ç–¾èµ°", a1:"ä½“è³ª", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"å™¨ç”¨"}, mag:{s1:"ç–¾èµ°", a1:"ä½“è³ª", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"ç²¾ç¥"}},
  {name:"æ°·é­„éˆ´è˜­", rank:2, phys:{s1:"ç–¾èµ°", a1:"ç­‹åŠ›", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"ä½“è³ª"}, mag:{s1:"ç–¾èµ°", a1:"ç²¾ç¥", s2:"PvPæ”»æ’ƒè£œæ­£", a2:"ä½“è³ª"}},
  /* name fixes */
  {name:"ãƒ©ãƒƒã‚³ãƒ«ãƒ‡ã‚£ãƒ¼ãƒ‹", rank:1, phys:{s1:"çŸ­ç¸®", a1:"ç­‹åŠ›", s2:"PvP HPè£œæ­£", a2:"å™¨ç”¨"}, mag:{s1:"çŸ­ç¸®", a1:"çŸ¥æµ", s2:"PvP HPè£œæ­£", a2:"ç²¾ç¥"}},
  {name:"ç™½è—ã®ã‚¢ã‚¸ã‚µã‚¤", rank:1, phys:{s1:"çŸ­ç¸®", a1:"ä½“è³ª", s2:"PvP HPè£œæ­£", a2:"å™¨ç”¨"}, mag:{s1:"çŸ­ç¸®", a1:"ä½“è³ª", s2:"PvP HPè£œæ­£", a2:"çŸ¥æµ"}},
  {name:"æ–°ç”Ÿã®æœé¡”", rank:1, phys:{s1:"çŸ­ç¸®", a1:"å™¨ç”¨", s2:"PvP HPè£œæ­£", a2:"ä½“è³ª"}, mag:{s1:"çŸ­ç¸®", a1:"çŸ¥æµ", s2:"PvP HPè£œæ­£", a2:"ä½“è³ª"}},
  {name:"ç¨²è·ç‹å®ˆ", rank:2, phys:{s1:"çŸ­ç¸®", a1:"ç­‹åŠ›", s2:"PvP HPè£œæ­£", a2:"å™¨ç”¨"}, mag:{s1:"çŸ­ç¸®", a1:"çŸ¥æµ", s2:"PvP HPè£œæ­£", a2:"ç²¾ç¥"}},
  {name:"ã‚­ãƒ³ã‚«ãƒ³", rank:1, phys:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"ä½“è³ª", s2:"å¼·å¥", a2:"ç­‹åŠ›"}, mag:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"ä½“è³ª", s2:"å¼·å¥", a2:"ç²¾ç¥"}},
  {name:"ã‚¹ã‚¤ãƒ¼ãƒˆãƒ™ãƒªãƒ¼", rank:1, phys:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"å™¨ç”¨", s2:"å¼·å¥", a2:"ä½“è³ª"}, mag:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"ç²¾ç¥", s2:"å¼·å¥", a2:"ä½“è³ª"}},
  {name:"ã‚¹ãƒªãƒ¼ãƒ”ãƒ³ã‚°ã‚­ãƒã‚³", rank:1, phys:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"ç­‹åŠ›", s2:"å¼·å¥", a2:"å™¨ç”¨"}, mag:{s1:"ãƒ–ãƒ­ãƒƒã‚¯æ€§èƒ½", a1:"ç²¾ç¥", s2:"å¼·å¥", a2:"çŸ¥æµ"}},
];

const ATTRS = ["ç­‹åŠ›","å™¨ç”¨","ä½“è³ª","çŸ¥æµ","ç²¾ç¥"];
const ATTR_EMOJI = { "ç­‹åŠ›":"ğŸ‹ï¸", "å™¨ç”¨":"ğŸ¯", "ä½“è³ª":"â¤ï¸", "çŸ¥æµ":"ğŸ§ ", "ç²¾ç¥":"âœ¨" };
const ATTR_COLOR_VAR = { "ç­‹åŠ›":"--c-ç­‹åŠ›", "å™¨ç”¨":"--c-å™¨ç”¨", "ä½“è³ª":"--c-ä½“è³ª", "çŸ¥æµ":"--c-çŸ¥æµ", "ç²¾ç¥":"--c-ç²¾ç¥" };

const ATTR_COLOR_CACHE = {};
function getAttrColor(attr){
  const vname = ATTR_COLOR_VAR[attr];
  if(!vname) return "";
  if(ATTR_COLOR_CACHE[vname]) return ATTR_COLOR_CACHE[vname];
  const v = getComputedStyle(document.documentElement).getPropertyValue(vname).trim();
  ATTR_COLOR_CACHE[vname] = v;
  return v;
}


const MAIN_REQ = [
  {lv:0, need:0},{lv:1, need:75},{lv:2, need:190},{lv:3, need:380},{lv:4, need:605},{lv:5, need:910},
  {lv:8, need:1215},{lv:8, need:1520},{lv:8, need:1650},{lv:9, need:1800},{lv:10, need:2060},{lv:11, need:2360},{lv:12, need:2520},{lv:13, need:2760},
];
const SUB_REQ = [
  {lv:0, need:0},{lv:1, need:75},{lv:2, need:190},{lv:3, need:380},{lv:4, need:605},{lv:5, need:910},
  {lv:8, need:1140},{lv:8, need:1365},{lv:8, need:1565},{lv:9, need:1740},
];

const REIIN = {
  1: {7:{single:190,double:114}, 8:{single:250,double:144}, 9:{single:340,double:189}},
  2: {7:{single:290,double:174}, 8:{single:390,double:224}, 9:{single:520,double:289}},
};

const NODES = [
  {r:0,c:3,id:"F2.L1",type:"L"}, {r:0,c:4,id:"F2.L2",type:"L"}, {r:0,c:5,id:"F2.L3",type:"L"},
  {r:1,c:1,id:"F1.L1",type:"L"}, {r:1,c:2,id:"F1.L2",type:"L"}, {r:1,c:3,id:"F1-F2.P1",type:"P"}, {r:1,c:4,id:"F2",type:"F"}, {r:1,c:5,id:"F2-F3.P1",type:"P"}, {r:1,c:6,id:"F3.L1",type:"L"}, {r:1,c:7,id:"F3.L2",type:"L"},
  {r:2,c:1,id:"F1.L3",type:"L"}, {r:2,c:2,id:"F1",type:"F"}, {r:2,c:3,id:"F1-F2.P2",type:"P"}, {r:2,c:4,id:"F2.L4",type:"L"}, {r:2,c:5,id:"F2-F3.P2",type:"P"}, {r:2,c:6,id:"F3",type:"F"}, {r:2,c:7,id:"F3.L3",type:"L"},
  {r:3,c:0,id:"F4.L1",type:"L"}, {r:3,c:1,id:"F1-F4.P1",type:"P"}, {r:3,c:2,id:"F1-F4.P2",type:"P"}, {r:3,c:3,id:"F0-F1.P1",type:"P"}, {r:3,c:4,id:"F0.L1",type:"L"}, {r:3,c:5,id:"F0-F3.P1",type:"P"}, {r:3,c:6,id:"F3-F5.P1",type:"P"}, {r:3,c:7,id:"F3-F5.P2",type:"P"}, {r:3,c:8,id:"F5.L1",type:"L"},
  {r:4,c:0,id:"F4.L2",type:"L"}, {r:4,c:1,id:"F4",type:"F"}, {r:4,c:2,id:"F4.L3",type:"L"}, {r:4,c:3,id:"F0.L2",type:"L"}, {r:4,c:4,id:"F0",type:"F"}, {r:4,c:5,id:"F0.L3",type:"L"}, {r:4,c:6,id:"F5.L2",type:"L"}, {r:4,c:7,id:"F5",type:"F"}, {r:4,c:8,id:"F5.L3",type:"L"},
  {r:5,c:0,id:"F4.L4",type:"L"}, {r:5,c:1,id:"F4-F6.P1",type:"P"}, {r:5,c:2,id:"F4-F6.P2",type:"P"}, {r:5,c:3,id:"F0-F6.P1",type:"P"}, {r:5,c:4,id:"F0.L4",type:"L"}, {r:5,c:5,id:"F0-F8.P1",type:"P"}, {r:5,c:6,id:"F5-F8.P1",type:"P"}, {r:5,c:7,id:"F5-F8.P2",type:"P"}, {r:5,c:8,id:"F5.L4",type:"L"},
  {r:6,c:1,id:"F6.L1",type:"L"}, {r:6,c:2,id:"F6",type:"F"}, {r:6,c:3,id:"F6-F7.P1",type:"P"}, {r:6,c:4,id:"F7.L1",type:"L"}, {r:6,c:5,id:"F7-F8.P1",type:"P"}, {r:6,c:6,id:"F8",type:"F"}, {r:6,c:7,id:"F8.L1",type:"L"},
  {r:7,c:1,id:"F6.L2",type:"L"}, {r:7,c:2,id:"F6.L3",type:"L"}, {r:7,c:3,id:"F6-F7.P2",type:"P"}, {r:7,c:4,id:"F7",type:"F"}, {r:7,c:5,id:"F7-F8.P2",type:"P"}, {r:7,c:6,id:"F8.L2",type:"L"}, {r:7,c:7,id:"F8.L3",type:"L"},
  {r:8,c:3,id:"F7.L2",type:"L"}, {r:8,c:4,id:"F7.L3",type:"L"}, {r:8,c:5,id:"F7.L4",type:"L"},
];

const FLOWER_IDS = ["F0","F1","F2","F3","F4","F5","F6","F7","F8"];
const OFFSETS = [
  {dr:-1,dc:0, dir:"U"}, {dr:1,dc:0, dir:"D"}, {dr:0,dc:-1, dir:"L"}, {dr:0,dc:1, dir:"R"},
  {dr:-1,dc:-1, dir:"UL"}, {dr:-1,dc:1, dir:"UR"}, {dr:1,dc:-1, dir:"DL"}, {dr:1,dc:1, dir:"DR"},
];

function enabledDirsByFlowerLevel(lv){
  const set = new Set(["U","D","L","R"]);
  if (lv >= 3) set.add("UL");
  if (lv >= 5) set.add("UR");
  if (lv >= 7) set.add("DL");
  if (lv >= 9) set.add("DR");
  return set;
}

const boardEl = document.getElementById("board");
const jobTypeEl = document.getElementById("jobType");
const modeSelEl = document.getElementById("modeSel");

const enforceInvEl = document.getElementById("enforceInv");
  const btnInvToggleEl = document.getElementById("btnInvToggle");
  const invSectionEl = document.getElementById("invSection");
  let invSectionOpen = true;
const enforceInvWrapEl = document.getElementById("enforceInvWrap");
const runeSearchEl = document.getElementById("runeSearch");

const addKindEl = document.getElementById("addKind");
const addA1El = document.getElementById("addA1");
const addA2Wrap = document.getElementById("addA2Wrap");
const addA2El = document.getElementById("addA2");
const addRankEl = document.getElementById("addRank");
const addEnhEl = document.getElementById("addEnh");
const addQtyEl = document.getElementById("addQty");


const remainTBodySide = document.getElementById("remainTBodySide");
const remainSideNote = document.getElementById("remainSideNote");

const kpiTotalCostEl = document.getElementById("kpiTotalCost");
const kpiModeEl = document.getElementById("kpiMode");
const kpiJobEl = document.getElementById("kpiJob");
const kpiInvGroupEl = document.getElementById("kpiInvGroup");
const kpiInvStatusEl = document.getElementById("kpiInvStatus");
const themeToggleEl = document.getElementById("themeToggle");
const themeLabelEl = document.getElementById("themeLabel");
const logEl = document.getElementById("log");
const flowerCardsEl = document.getElementById("flowerCards");
const invTBody = document.querySelector("#invTable tbody");

const detailTBody = document.getElementById("detailTBody");
const totalCostUniqueEl = document.getElementById("totalCostUnique");

const nodeByPos = new Map(NODES.map(n=>[`${n.r}-${n.c}`, n]));
const nodeById  = new Map(NODES.map(n=>[n.id, n]));

const absorbMap = new Map();
function buildAbsorbMap(){
  absorbMap.clear();
  for (const fid of FLOWER_IDS){
    const fnode = nodeById.get(fid);
    if (!fnode) continue;
    const mp = {};
    for (const off of OFFSETS){
      const key = `${fnode.r + off.dr}-${fnode.c + off.dc}`;
      const n = nodeByPos.get(key);
      if (n && n.type !== "F"){
        mp[off.dir] = n.id;
      }
    }
    absorbMap.set(fid, mp);
  }
}
buildAbsorbMap();

const state = {
  flowers: Object.fromEntries(FLOWER_IDS.map(id=>[id,""])),
  flowerLv: Object.fromEntries(FLOWER_IDS.map(id=>[id,9])),
  runes: {},
  inv: [],
};

function log(msg){
  if (!logEl) return;
  if (logEl.textContent === "-") logEl.textContent = "";
  logEl.textContent += (logEl.textContent ? "\n" : "") + msg;
  logEl.scrollTop = logEl.scrollHeight;
}

function allowedAttrsByJob(job){
  return job === "phys" ? ["ç­‹åŠ›","å™¨ç”¨","ä½“è³ª"] : ["çŸ¥æµ","ç²¾ç¥","ä½“è³ª"];
}

function fillSelect(sel, values, selected){
  sel.innerHTML = "";
  for (const v of values){
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    if (selected && selected===v) opt.selected = true;
    sel.appendChild(opt);
  }
}

function updateAddForm(){
  const job = jobTypeEl.value;
  const allowed = allowedAttrsByJob(job);
  const kind = addKindEl.value;

  // Attr1
  const curA1 = addA1El.value || allowed[0];
  fillSelect(addA1El, allowed, curA1);

  // Attr2 for double
  if (kind === "double"){
    addA2Wrap.style.display = "";
    addA2Wrap.style.visibility = "";
    addA2Wrap.style.pointerEvents = "";
    const a1 = addA1El.value;
    const allowed2 = allowed.filter(a => a !== a1);
    const curA2 = allowed2.includes(addA2El.value) ? addA2El.value : allowed2[0];
    fillSelect(addA2El, allowed2, curA2);
    addA2El.disabled = false;
  } else {
    // keep layout width so the add button doesn't jump between single/double
    addA2Wrap.style.display = "";
    addA2Wrap.style.visibility = "hidden";
    addA2Wrap.style.pointerEvents = "none";
    addA2El.disabled = true;
  }
}



function canonPair(a,b){ return [a,b].sort().join("+"); }
function attrClass(attr){ return `attr-${attr}`; }

function runeKey(spec){
  if (spec.kind==="single"){
    return `${spec.kind}|${spec.attrs[0]}|R${spec.rank}|+${spec.enh}`;
  }
  return `${spec.kind}|${canonPair(spec.attrs[0], spec.attrs[1])}|R${spec.rank}|+${spec.enh}`;
}

function runeValueSingle(rank, enh){ return REIIN[rank]?.[enh]?.single ?? 0; }
function runeValueDouble(rank, enh){ return REIIN[rank]?.[enh]?.double ?? 0; }

const RUNE_COST = {
  1: {7:47, 8:94, 9:188},
  2: {7:100, 8:200, 9:400},
};
function runeCost(rank, enh){
  return (RUNE_COST[rank] && RUNE_COST[rank][enh]) ? RUNE_COST[rank][enh] : 0;
}

function labelFromRuneKey(k){
  // k: "single|ç­‹åŠ›|R1|+7" or "double|ç­‹åŠ›+å™¨ç”¨|R2|+9"
  const parts = String(k||"").split("|");
  if (parts.length < 4) return k;
  const kind = parts[0];
  const attrs = parts[1];
  const rank = parts[2].replace(/^R/,"");
  const enh  = parts[3].replace(/^\+/,"");
  const kindMark = (kind==="single") ? "S" : "D";
  return `${attrs} R${rank} +${enh} ${kindMark}`;
}

function renderRemainTableInto(tbody){
  if (!tbody) return;

  const invModeNow = (modeSelEl && modeSelEl.value === "inv");
  const enforceNow = invModeNow; // æ‰‹æŒã¡éœŠéŸ»ã®ã¿ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¸¸æ™‚æ›´æ–°

  tbody.innerHTML = "";
  if (!enforceNow){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="small">ï¼ˆæ‰‹æŒã¡éœŠéŸ»ã®ã¿ãƒ¢ãƒ¼ãƒ‰æ™‚ã«è¡¨ç¤ºï¼‰</td>`;
    tbody.appendChild(tr);
    return {status:"off", over:false, empty:false};
  }

  const have = new Map();
  for (const it of state.inv){
    const qty = Number(it.qty || 0);
    if (qty <= 0) continue;
    const k = runeKey(it);
    have.set(k, (have.get(k) || 0) + qty);
  }

  const used = new Map();
  for (const spec of Object.values(state.runes)){
    if (!spec) continue;
    const k = runeKey(spec);
    used.set(k, (used.get(k) || 0) + 1);
  }

  const keys = Array.from(new Set([...have.keys(), ...used.keys()])).sort();
  if (keys.length===0){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="small">ï¼ˆ-ï¼‰</td>`;
    tbody.appendChild(tr);
    return {status:"empty", over:false, empty:true};
  }

  let over = false;
  for (const k of keys){
    const h = have.get(k) || 0;
    const u = used.get(k) || 0;
    const r = h - u;
    if (r < 0) over = true;
    const tr = document.createElement("tr");
    const warnStyle = (r < 0) ? ' style="color:#b00020; font-weight:800;"' : '';
    tr.innerHTML = `
      <td class="nowrap">${labelFromRuneKey(k)}</td>
      <td>${h}</td>
      <td>${u}</td>
      <td${warnStyle}>${r}</td>
    `;
    tbody.appendChild(tr);
  }
  return {status:"on", over, empty:false};
}

function renderRemainTable(){
  const r = renderRemainTableInto(remainTBodySide);

  // Side note
  const invModeNow = (modeSelEl && modeSelEl.value === "inv");
  if (remainSideNote){
    remainSideNote.textContent = invModeNow
      ? "â€»ã€Œæ‰‹æŒã¡éœŠéŸ»ã®ã¿ã€ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æ›´æ–°"
      : "â€»ã€Œæ‰‹æŒã¡éœŠéŸ»ã®ã¿ã€ãƒ¢ãƒ¼ãƒ‰ã§è¡¨ç¤º";
  }

  // KPI inventory: show ONLY when over (avoid noisy "æœªç™»éŒ²" in header)
  if (kpiInvGroupEl){
    kpiInvGroupEl.style.display = (invModeNow && r?.over) ? "" : "none";
  }
  if (kpiInvStatusEl){
    kpiInvStatusEl.textContent = "è¶…éã‚ã‚Š";
  }
}


function updateInvToggleLabel(){
  if (!btnInvToggleEl) return;
  const invModeNow = (modeSelEl && modeSelEl.value === "inv");
  if (!invModeNow){
    btnInvToggleEl.textContent = "éœŠéŸ»ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª";
    btnInvToggleEl.setAttribute("aria-expanded","false");
    return;
  }
  const open = !!invSectionOpen;
  btnInvToggleEl.textContent = open ? "éœŠéŸ»ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼ˆé–‰ã˜ã‚‹ï¼‰" : "éœŠéŸ»ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼ˆé–‹ãï¼‰";
  btnInvToggleEl.setAttribute("aria-expanded", open ? "true" : "false");
}

function updateTopbar(){
  if (kpiModeEl && modeSelEl){
    kpiModeEl.textContent = (modeSelEl.value === "inv") ? "æ‰‹æŒã¡éœŠéŸ»ã®ã¿" : "è‡ªç”±è¨­è¨ˆ";
  }
  if (kpiJobEl && jobTypeEl){
    kpiJobEl.textContent = (jobTypeEl.value === "mag") ? "é­”æ³•è·" : "ç‰©ç†è·";
  }
  // total cost is updated by recalc; keep a safe fallback
  if (kpiTotalCostEl && totalCostUniqueEl){
    kpiTotalCostEl.textContent = totalCostUniqueEl.textContent;
  }
  updateInvToggleLabel();
}

let __runeOptRAF = 0;
function updateRuneOptions(){
  // ãƒ¢ãƒ¼ãƒ‰/è·ã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«éœŠéŸ»ãƒªã‚¹ãƒˆ(ç›¤é¢å«ã‚€)ã‚’ä½œã‚Šç›´ã—ã¦å³æ™‚åæ˜ 
  if (__runeOptRAF) cancelAnimationFrame(__runeOptRAF);
  __runeOptRAF = requestAnimationFrame(()=>{
    __runeOptRAF = 0;
    try { buildBoard(); } catch(e){}
    try { recalc(); } catch(e){}
  });
}

function cssVarValue(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || "#fff";
}

function badgeStyle(b){
  const text = {top:`R${b.rank}`, bot:`+${b.enh}`};
  if (b.kind==="single"){
    return {cls:`single ${attrClass(b.a1)}`, style:"", text};
  }
  const c1 = cssVarValue(ATTR_COLOR_VAR[b.a1]);
  const c2 = cssVarValue(ATTR_COLOR_VAR[b.a2]);
  return {cls:`double`, style:`background: linear-gradient(135deg, ${c1} 0 50%, ${c2} 50% 100%);`, text};
}

function runeOptions(job, q){
  const allowed = allowedAttrsByJob(job);
  const opts = [];

  for (const attr of allowed){
    for (const rank of [1,2]){
      for (const enh of [7,8,9]){
        const val = runeValueSingle(rank, enh);
        const short = `R${rank} ${attr} +${enh} (${val})`;
        const spec = {kind:"single", attrs:[attr], rank, enh};
        opts.push({key:runeKey(spec), spec, short, badge:{kind:"single", a1:attr, a2:null, rank, enh}});
      }
    }
  }

  for (let i=0;i<allowed.length;i++){
    for (let j=i+1;j<allowed.length;j++){
      const a1 = allowed[i], a2 = allowed[j];
      for (const rank of [1,2]){
        for (const enh of [7,8,9]){
          const val = runeValueDouble(rank, enh);
          const short = `R${rank} ${a1}+${a2} +${enh} (${val}Ã—2)`;
          const spec = {kind:"double", attrs:[a1,a2], rank, enh};
          opts.push({key:runeKey(spec), spec, short, badge:{kind:"double", a1, a2, rank, enh}});
        }
      }
    }
  }

  // mode=inv: filter options to inventory-only (qty>0)
  let res = opts;
  if (modeSelEl && modeSelEl.value === "inv"){
    const keys = new Set(state.inv.filter(it=>Number(it.qty||0)>0).map(it => runeKey(it)));
    res = res.filter(o => keys.has(o.key));
  }

  const qq = (q||"").trim().toLowerCase();
  if (!qq) return res;
  return res.filter(o => o.short.toLowerCase().includes(qq));
}

/* Flower options without duplicates:
   For each F slot: show (èŠ±å¾¡ãªã—) + (current selection if any) + (not-selected flowers) */
function selectedFlowerNames(){
  const set = new Set();
  for (const fid of FLOWER_IDS){
    const v = state.flowers[fid];
    if (v) set.add(v);
  }
  return set;
}


function fitBoardToPane(){
  // Resize tile size so the 9x9 board fits the available width without being clipped
  const wrap = document.querySelector('.boardWrap');
  if (!wrap) return;

  // Measure available width inside the wrap
  const availW = Math.max(0, wrap.clientWidth - 2);
  if (!availW) return;

  // Board sizing constants (must match CSS: gap=8, padding=8)
  const GAP = 8;
  const PAD = 8;
  const cols = 9;

  // Current base ratio between tile width and height (70/92 â‰’ 0.761)
  const ratioH = 70/92;

  // Compute tile width to fit: availW >= cols*tile + (cols-1)*GAP + PAD*2
  const maxTile = Math.floor((availW - (cols-1)*GAP - PAD*2) / cols);

  // Clamp tile size for usability
  const tile = Math.max(28, Math.min(92, maxTile));
  const tileH = Math.round(tile * ratioH);

  // Apply as CSS variables (layout size truly shrinks; no transform/clip issues)
  wrap.style.setProperty('--tile', tile + 'px');
  wrap.style.setProperty('--tileH', tileH + 'px');
}
window.addEventListener('resize', () => {
  // Defer to allow layout to settle
  window.requestAnimationFrame(fitBoardToPane);
});

function buildBoard(lastComputed){
  const job = jobTypeEl.value;
  const q = (runeSearchEl ? runeSearchEl.value : "");
  boardEl.innerHTML = "";

  const opts = runeOptions(job, q);

  const invMode = (modeSelEl && modeSelEl.value === "inv");
  const enforceInv = invMode && enforceInvEl.checked;

  // Inventory-aware option disabling: prevent selecting beyond qty in inv mode
  const have = new Map();
  if (enforceInv){
    for (const it of state.inv){
      const qty = Number(it.qty || 0);
      if (qty <= 0) continue;
      const k = runeKey(it);
      have.set(k, (have.get(k) || 0) + qty);
    }
  }
  const used = new Map();
  if (enforceInv){
    for (const [slotId, spec] of Object.entries(state.runes)){
      if (!spec) continue;
      const k = runeKey(spec);
      used.set(k, (used.get(k) || 0) + 1);
    }
  }

  const optByKey = new Map(opts.map(o=>[o.key,o]));
  const selected = selectedFlowerNames();

  for (let r=0;r<9;r++){
    for (let c=0;c<9;c++){
      const n = nodeByPos.get(`${r}-${c}`);
      if (!n){
        const ph = document.createElement("div");
        ph.style.minWidth = "var(--tile)";
        ph.style.minHeight = "var(--tileH)";
        ph.style.opacity = "0";
        boardEl.appendChild(ph);
        continue;
      }

      const tile = document.createElement("div");
      tile.className = "tile " + (n.type==="F" ? "flower" : n.type==="L" ? "l" : "p");

      if (n.type !== "F" && lastComputed?.slotActive){
        const active = lastComputed.slotActive.get(n.id) || false;
        if (!active) tile.classList.add("off");
      }

      const head = document.createElement("div");
      head.className = "idline";
      head.innerHTML = `<span>${n.id}</span><small>${n.type}</small>`;
      tile.appendChild(head);

      if (n.type === "F"){
        const badge = document.createElement("div");
        badge.className = "badge";

        const info = lastComputed?.flowerSkillLv?.[n.id] || {s1:"-",s2:"-"};
        const a1 = lastComputed?.flowerAttrs?.[n.id]?.a1 || "";
        const a2 = lastComputed?.flowerAttrs?.[n.id]?.a2 || "";

        const s1 = document.createElement("div"); s1.className = "sq " + (a1?attrClass(a1):""); s1.textContent = info.s1 ?? "-";
        const s2 = document.createElement("div"); s2.className = "sq " + (a2?attrClass(a2):""); s2.textContent = info.s2 ?? "-";
        badge.appendChild(s1); badge.appendChild(s2);
        tile.appendChild(badge);

        const lvl = document.createElement("div");
        lvl.className = "lvl";
        lvl.innerHTML = `<span><span class="lvtxt">Lv</span>${state.flowerLv[n.id]}</span>`;
        tile.appendChild(lvl);

        const current = state.flowers[n.id] || "";
        const sel = document.createElement("select");
        sel.id = "rsel_" + n.id;

        const o0 = document.createElement("option");
        o0.value = ""; o0.textContent = "(èŠ±å¾¡ãªã—)";
        sel.appendChild(o0);

        // Build list: keep current even if selected elsewhere (shouldn't happen after logic),
        // and exclude selected flowers from other slots.
        for (const f of FLOWERS){
          const isSelectedSomewhere = selected.has(f.name);
          const isCurrent = (f.name === current);
          if (isSelectedSomewhere && !isCurrent) continue;

          const o = document.createElement("option");
          o.value = f.name;
          o.textContent = `${f.name}ï¼ˆR${f.rank}ï¼‰`;
          sel.appendChild(o);
        }

        sel.value = current;
        sel.addEventListener("change", ()=>{
          state.flowers[n.id] = sel.value;

          // Extra safety: if user somehow created duplicates (e.g., via import),
          // auto-clear the same flower from other slots.
          if (sel.value){
            for (const fid of FLOWER_IDS){
              if (fid === n.id) continue;
              if (state.flowers[fid] === sel.value){
                state.flowers[fid] = "";
              }
            }
          }
          recalc();
        });
        tile.appendChild(sel);
    // èŠ±å¾¡åã¯ã€ŒLvé¸æŠã¨åŒã˜è¡Œã€ã«çœç•¥è¡¨ç¤ºï¼ˆé«˜ã•ã‚’å¢—ã‚„ã•ãšã€LvãŒåŸ‹ã‚‚ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰
    const lvRow = document.createElement("div");
    lvRow.className = "sub flower-sub";

    const lvSel = document.createElement("select");
    [1,3,5,7,9].forEach(v=>{
      const o = document.createElement("option");
      o.value = String(v);
      o.textContent = "Lv " + String(v);
      lvSel.appendChild(o);
    });
    lvSel.value = String(state.flowerLv[n.id]||9);
    lvSel.addEventListener("change",()=>{ state.flowerLv[n.id]=Number(lvSel.value)||9; recalc(); });
    lvRow.appendChild(lvSel);
    tile.appendChild(lvRow);

    // è¡¨ç¤ºæ›´æ–°ï¼ˆé¸æŠåã®è¿½å¾“ï¼‰
    sel.addEventListener("change",()=>{
      fn.textContent = sel.value || "";
      fn.title = fn.textContent;
      fn.style.display = sel.value ? "block" : "none";
    });
      } else {
        const currentSpec = state.runes[n.id];
        if (currentSpec){
          const b = {kind: currentSpec.kind, a1: currentSpec.attrs[0], a2: currentSpec.kind==="double"? currentSpec.attrs[1] : null, rank: currentSpec.rank, enh: currentSpec.enh};
          const {cls, style, text} = badgeStyle(b);
          const bd = document.createElement("div");
          bd.className = `rbadge ${cls}`;
          if (style) bd.setAttribute("style", style);
          bd.innerHTML = `<div class="t"><span>${text.top}</span><span>${text.bot}</span></div>`;
          tile.appendChild(bd);
        }

        const sel = document.createElement("select");
        const o0 = document.createElement("option");
        o0.value = ""; o0.textContent = "(éœŠéŸ»ãªã—)";
        sel.appendChild(o0);

        const currentKey = currentSpec ? runeKey(currentSpec) : "";
        let currentStillVisible = false;

        for (const opt of opts){
          const o = document.createElement("option");
          o.value = opt.key;
          o.textContent = opt.short;
          if (enforceInv){
            const h = have.get(opt.key) || 0;
            const u = used.get(opt.key) || 0;
            const remaining = h - u + ((opt.key === currentKey) ? 1 : 0);
            if (remaining <= 0 && opt.key !== currentKey){
              o.disabled = true;
              o.textContent += "ï¼ˆåœ¨åº«0ï¼‰";
            } else {
              o.textContent += `ï¼ˆæ®‹${remaining}ï¼‰`;
            }
          }
          // colorize option text by first attribute
          const a0 = opt.spec?.attrs?.[0];
          const c0 = getAttrColor(a0);
          if(c0) o.style.color = c0;
          if(opt.spec?.kind==="double"){
            const c1 = getAttrColor(opt.spec.attrs?.[0]);
            const c2 = getAttrColor(opt.spec.attrs?.[1]);
            if(c1 && c2){
              o.style.backgroundImage = `linear-gradient(90deg, ${c1} 0%, ${c1} 50%, ${c2} 50%, ${c2} 100%)`;
              o.style.color = "#111";
            }
          }
          if(opt.spec?.rank===2) o.style.fontWeight = "700";
          if (o.value === currentKey) currentStillVisible = true;
          sel.appendChild(o);
        }

        if (currentKey && !currentStillVisible){
          const cs = currentSpec;
          const val = (cs.kind==="single") ? runeValueSingle(cs.rank, cs.enh) : runeValueDouble(cs.rank, cs.enh);
          const short = (cs.kind==="single")
            ? `R${cs.rank} ${cs.attrs[0]} +${cs.enh} (${val})ï¼ˆãƒ•ã‚£ãƒ«ã‚¿å¤–ï¼‰`
            : `R${cs.rank} ${cs.attrs[0]}+${cs.attrs[1]} +${cs.enh} (${val}Ã—2)ï¼ˆãƒ•ã‚£ãƒ«ã‚¿å¤–ï¼‰`;
          const o = document.createElement("option");
          o.value = currentKey;
          o.textContent = short;
          const c0 = getAttrColor(cs.attrs?.[0]);
          if(c0) o.style.color = c0;
          if(cs.kind==="double"){
            const c1 = getAttrColor(cs.attrs?.[0]);
            const c2 = getAttrColor(cs.attrs?.[1]);
            if(c1 && c2){
              o.style.backgroundImage = `linear-gradient(90deg, ${c1} 0%, ${c1} 50%, ${c2} 50%, ${c2} 100%)`;
              o.style.color = "#111";
            }
          }
          if(cs.kind==="double") o.style.fontWeight = "700";
          sel.appendChild(o);
        }

        sel.value = currentKey || "";
        sel.addEventListener("change", ()=>{
          const key = sel.value;
          const invModeNow = (modeSelEl && modeSelEl.value === "inv");
          const enforceNow = invModeNow; // æ‰‹æŒã¡éœŠéŸ»ã®ã¿ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¸¸æ™‚æ›´æ–°

          const currentSpec2 = state.runes[n.id];
          const currentKey2 = currentSpec2 ? runeKey(currentSpec2) : "";

          if (!key) { delete state.runes[n.id]; recalc(); return; }

          // Hard guard: in inventory mode with enforcement, block selections that exceed qty.
          if (enforceNow){
            const have2 = new Map();
            for (const it of state.inv){
              const qty = Number(it.qty || 0);
              if (qty <= 0) continue;
              const k = runeKey(it);
              have2.set(k, (have2.get(k) || 0) + qty);
            }
            const used2 = new Map();
            for (const spec of Object.values(state.runes)){
              if (!spec) continue;
              const k = runeKey(spec);
              used2.set(k, (used2.get(k) || 0) + 1);
            }
            // remove current slot consumption
            if (currentKey2){
              used2.set(currentKey2, (used2.get(currentKey2) || 0) - 1);
            }
            const h = have2.get(key) || 0;
            const u = used2.get(key) || 0;
            if (u + 1 > h){
              alert("åœ¨åº«æ•°ã‚’è¶…ãˆã‚‹ãŸã‚ã€ã“ã®éœŠéŸ»ã¯ã“ã‚Œä»¥ä¸Šè¨­ç½®ã§ãã¾ã›ã‚“ã€‚");
              sel.value = currentKey2 || "";
              return;
            }
          }

          const opt = optByKey.get(key);
          if (!opt) { alert("å†…éƒ¨ã‚¨ãƒ©ãƒ¼ï¼šéœŠéŸ»ãŒè¦‹ã¤ã‹ã‚‰ãªã„"); return; }
          state.runes[n.id] = opt.spec;
          recalc();
        });
        tile.appendChild(sel);

        const sub = document.createElement("div");
        sub.className = "mini";
        if (lastComputed?.slotConsumers){
          const consumers = lastComputed.slotConsumers.get(n.id) || [];
          sub.textContent = consumers.length ? `å¸ã„å–ã‚Šï¼š${consumers.join(",")}` : "å¸ã„å–ã‚Šï¼šãªã—";
        } else {
          sub.textContent = n.type==="P" ? "å…±æœ‰ã‚¹ãƒ­ãƒƒãƒˆ" : "å˜ä½“ã‚¹ãƒ­ãƒƒãƒˆ";
        }
        tile.appendChild(sub);
      }

      boardEl.appendChild(tile);
    }
  }
}

function buildInvTable(){
  if (!invTBody) return; // inv UI is hidden/absent outside æ‰‹æŒã¡éœŠéŸ»ã®ã¿
  invTBody.innerHTML = "";
  if (state.inv.length===0){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="6" class="small">ï¼ˆåœ¨åº«ã¯æœªç™»éŒ²ã€‚å¿…è¦ãªã‚‰ã€ŒéœŠéŸ»ã‚’è¿½åŠ ã€ï¼‰</td>`;
    invTBody.appendChild(tr);
    return;
  }
  state.inv.forEach((it, idx)=>{
    const attrLabel = (it.kind==="single") ? `${ATTR_EMOJI[it.attrs[0]]??""} ${it.attrs[0]}`
      : `${ATTR_EMOJI[it.attrs[0]]??""}${it.attrs[0]} + ${ATTR_EMOJI[it.attrs[1]]??""}${it.attrs[1]}`;
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${attrLabel}</td>
      <td>R${it.rank}</td>
      <td>+${it.enh}</td>
      <td>${it.kind==="single"?"ã‚·ãƒ³ã‚°ãƒ«":"ãƒ€ãƒ–ãƒ«"}</td>
      <td><input type="number" min="0" step="1" value="${it.qty}" data-idx="${idx}" style="width:80px"/></td>
      <td><button data-del="${idx}">å‰Šé™¤</button></td>`;
    invTBody.appendChild(tr);
  });

  invTBody.querySelectorAll("input[type=number]").forEach(inp=>{
    inp.addEventListener("change", ()=>{
      const idx = Number(inp.dataset.idx);
      state.inv[idx].qty = Math.max(0, Number(inp.value||0));
      recalc();
    });
  });
  invTBody.querySelectorAll("button[data-del]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const idx = Number(btn.dataset.del);
      state.inv.splice(idx,1);
      buildInvTable();
      recalc();
    });
  });
}

function levelFromPoints(points, reqTable){
  let lv = 0;
  for (const row of reqTable) if (points >= row.need) lv = row.lv;
  const nextRow = reqTable.find(r=>r.lv===lv+1);
  const nextNeed = nextRow ? Math.max(0, nextRow.need - points) : 0;
  return {lv, nextNeed};
}


function recalc(){
  if (logEl) logEl.textContent = "-";
  const invMode = (modeSelEl && modeSelEl.value === "inv");
  const enforceInv = invMode && enforceInvEl.checked;

  const slotConsumers = new Map();
  const slotActive = new Map();
  for (const n of NODES){
    if (n.type==="F") continue;
    slotConsumers.set(n.id, []);
    slotActive.set(n.id, false);
  }

  // duplicates should not exist, but detect anyway
  const chosen = Object.values(state.flowers).filter(Boolean);
  const dups = chosen.filter((x,i)=>chosen.indexOf(x)!==i);

  const points = Object.fromEntries(FLOWER_IDS.map(fid=>[fid, Object.fromEntries(ATTRS.map(a=>[a,0])) ]));

  for (const fid of FLOWER_IDS){
    const dirs = enabledDirsByFlowerLevel(Number(state.flowerLv[fid]||1));
    const mp = absorbMap.get(fid) || {};
    for (const [dir, slotId] of Object.entries(mp)){
      if (!dirs.has(dir)) continue;
      slotActive.set(slotId, true);
      slotConsumers.get(slotId)?.push(fid);

      const spec = state.runes[slotId];
      if (!spec) continue;

      if (spec.kind==="single"){
        points[fid][spec.attrs[0]] += runeValueSingle(spec.rank, spec.enh);
      } else {
        const v = runeValueDouble(spec.rank, spec.enh);
        points[fid][spec.attrs[0]] += v;
        points[fid][spec.attrs[1]] += v;
      }
    }
  }

  const job = jobTypeEl.value;
  const flowerSkillLv = {};
  const flowerAttrs = {};
  if (flowerCardsEl) flowerCardsEl.innerHTML = "";
  let lvSum = 0;
  let needSum = 0;

  for (const fid of FLOWER_IDS){
    const fname = state.flowers[fid];
    const flv = Number(state.flowerLv[fid]||1);

    const card = document.createElement("div");
    card.className = "fcard";

    if (!fname){
      flowerSkillLv[fid] = {s1:"-", s2:"-"};
      flowerAttrs[fid] = {a1:"", a2:""};

      card.innerHTML = `
        <div class="fcardHead">
          <div class="fcardTitle">
            <span class="tag">${fid}</span>
            <span class="small">(ãªã—)</span>
          </div>
          <span class="tag lv">èŠ±å¾¡Lv ${flv}</span>
        </div>
        <div class="small">ã‚¹ã‚­ãƒ«æƒ…å ±ï¼š-</div>
      `;
      if (flowerCardsEl) flowerCardsEl.appendChild(card);
      continue;
    }

    const master = FLOWERS.find(x=>x.name===fname);
    const profile = master?.[job];
    const s1 = profile?.s1 ?? "?";
    const a1 = profile?.a1 ?? "?";
    const s2 = profile?.s2 ?? "?";
    const a2 = profile?.a2 ?? "?";
    flowerAttrs[fid] = {a1, a2};

    const p1 = points[fid]?.[a1] ?? 0;
    const p2 = points[fid]?.[a2] ?? 0;

    const lv1 = levelFromPoints(p1, MAIN_REQ);
    const lv2 = levelFromPoints(p2, SUB_REQ);

    flowerSkillLv[fid] = {s1: String(lv1.lv), s2: String(lv2.lv)};

    lvSum += (lv1.lv + lv2.lv);
    needSum += (lv1.nextNeed + lv2.nextNeed);

    const next1 = (lv1.nextNeed===0) ? '<span class="ok">åˆ°é”</span>' : `<span class="warn">${lv1.nextNeed.toFixed(0)}</span>`;
    const next2 = (lv2.nextNeed===0) ? '<span class="ok">åˆ°é”</span>' : `<span class="warn">${lv2.nextNeed.toFixed(0)}</span>`;

    card.innerHTML = `
      <div class="fcardHead">
        <div class="fcardTitle">
          <span class="tag">${fid}</span>
          <span>${fname}ï¼ˆR${master?.rank ?? "?"}ï¼‰</span>
        </div>
        <span class="tag lv">èŠ±å¾¡Lv ${flv}</span>
      </div>

      <div class="fgrid">
        <div class="skillBox">
          <div>
            <div class="skillName">${s1} / ${ATTR_EMOJI[a1]??""} ${a1}</div>
            <div class="skillMeta">Pt: ${p1.toFixed(0)}</div>
          </div>
          <div class="skillLv">
            <div class="big">${lv1.lv}</div>
            <div class="next">æ¬¡ã¾ã§: ${next1}</div>
          </div>
        </div>

        <div class="skillBox">
          <div>
            <div class="skillName">${s2} / ${ATTR_EMOJI[a2]??""} ${a2}</div>
            <div class="skillMeta">Pt: ${p2.toFixed(0)}</div>
          </div>
          <div class="skillLv">
            <div class="big">${lv2.lv}</div>
            <div class="next">æ¬¡ã¾ã§: ${next2}</div>
          </div>
        </div>
      </div>
    `;
    if (flowerCardsEl) flowerCardsEl.appendChild(card);
  }

  if (!enforceInv){  } else {
    const used = new Map();
    for (const spec of Object.values(state.runes)){
      const k = runeKey(spec);
      used.set(k, (used.get(k)||0)+1);
    }
    const have = new Map();
    for (const it of state.inv){
      const k = runeKey(it);
      have.set(k, (have.get(k)||0) + it.qty);
    }
    const over = [];
    for (const [k,c] of used.entries()){
      const h = have.get(k)||0;
      if (c>h) over.push({k, used:c, have:h});
    }
    if (over.length===0){      log("åœ¨åº«åˆ¶é™ï¼šOKï¼ˆè¶…éãªã—ï¼‰");
    } else {      log("âš ï¸ åœ¨åº«è¶…éã‚ã‚Šï¼š");
      over.forEach(o=>log(`- ${o.k} ä½¿:${o.used} / æŒ:${o.have}`));
    }
  }


  // ----- v14.2: Cost aggregation & F0 detail table -----
  const costByFlower = Object.fromEntries(FLOWER_IDS.map(fid=>[fid,0]));
  let totalCostUnique = 0;
  for (const [slotId, active] of slotActive.entries()){
    if (!active) continue;
    const spec = state.runes[slotId];
    if (!spec) continue;
    const c = runeCost(spec.rank, spec.enh);
    totalCostUnique += c;
    const consumers = slotConsumers.get(slotId) || [];
    for (const fid of consumers){
      costByFlower[fid] = (costByFlower[fid] || 0) + c;
    }
  }

  // Render F0 details (under the board)
  if (detailTBody){
    detailTBody.innerHTML = "";
    const job = jobTypeEl.value;
    for (const fid of FLOWER_IDS){
      const fname = state.flowers[fid] || "";
      if (!fname){
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${fid}</td><td class="small">ï¼ˆæœªé¸æŠï¼‰</td><td>-</td><td>0</td><td>0</td><td class="grp1">-</td><td>-</td><td>0</td><td>0</td><td>-</td><td>0</td>`;
        detailTBody.appendChild(tr);
        continue;
      }
      const f = FLOWERS.find(x=>x.name===fname);
      const profile = (job==="phys") ? f?.phys : f?.mag;
      const s1 = profile?.s1 ?? "?";
      const a1 = profile?.a1 ?? "?";
      const s2 = profile?.s2 ?? "?";
      const a2 = profile?.a2 ?? "?";

      const p1 = points[fid]?.[a1] ?? 0;
      const p2 = points[fid]?.[a2] ?? 0;
      const lv1 = levelFromPoints(p1, MAIN_REQ);
      const lv2 = levelFromPoints(p2, SUB_REQ);

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${fid}</td>
        <td class="nowrap">${fname}</td>
        <td class="nowrap">${s1}</td>
        <td>${lv1.lv}</td>
        <td>${p1}</td>
        <td class="grp1">${lv1.nextNeed===0 ? '<span class="ok">åˆ°é”</span>' : lv1.nextNeed}</td>
        <td class="nowrap">${s2}</td>
        <td>${lv2.lv}</td>
        <td>${p2}</td>
        <td>${lv2.nextNeed===0 ? '<span class="ok">åˆ°é”</span>' : lv2.nextNeed}</td>
        <td>${costByFlower[fid] || 0}</td>
      `;
      detailTBody.appendChild(tr);
    }
  }
  if (totalCostUniqueEl) totalCostUniqueEl.textContent = String(totalCostUnique);
  if (kpiTotalCostEl) kpiTotalCostEl.textContent = String(totalCostUnique);
  if (kpiModeEl) kpiModeEl.textContent = (invMode ? "æ‰‹æŒã¡éœŠéŸ»ã®ã¿" : "è‡ªç”±è¨­è¨ˆ");
  if (kpiJobEl) kpiJobEl.textContent = (jobTypeEl.value==="phys" ? "ç‰©ç†è·" : "é­”æ³•è·");

  renderRemainTable();

  buildBoard({flowerSkillLv, flowerAttrs, slotConsumers, slotActive});
  window.requestAnimationFrame(fitBoardToPane);
}

function exportJson(){
  const payload = {
    v:8,
    jobType: jobTypeEl.value,
    runeSearch: (runeSearchEl ? runeSearchEl.value : ""),
    enforceInv: enforceInvEl.checked,
    flowers: state.flowers,
    flowerLv: state.flowerLv,
    runes: state.runes,
    inv: state.inv,
  };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "hanami_config_v8.json";
  a.click();
  URL.revokeObjectURL(url);
}

function importJson(){
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = ".json,application/json";
  inp.addEventListener("change", ()=>{
    const file = inp.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const data = JSON.parse(String(reader.result||"{}"));
        if (data.v !== 8) throw new Error("v8 JSONã˜ã‚ƒãªã„");
        jobTypeEl.value = data.jobType || "phys";
        if (runeSearchEl) runeSearchEl.value = data.runeSearch || "";
        enforceInvEl.checked = !!data.enforceInv;
        state.flowers = data.flowers || state.flowers;
        state.flowerLv = data.flowerLv || state.flowerLv;
        state.runes = data.runes || {};
        state.inv = Array.isArray(data.inv) ? data.inv : [];
        // sanitize duplicates after import
        const seen = new Set();
        for (const fid of FLOWER_IDS){
          const v = state.flowers[fid];
          if (!v) continue;
          if (seen.has(v)) state.flowers[fid] = "";
          else seen.add(v);
        }
        buildInvTable();
        recalc();
      }catch(e){
        alert("JSONèª­ã¿è¾¼ã¿å¤±æ•—: " + e.message);
      }
    };
    reader.readAsText(file, "utf-8");
  });
  inp.click();
}

document.getElementById("btnAddInv").addEventListener("click", ()=>{
  const kind = addKindEl.value;
  const a1 = addA1El.value;
  const a2 = addA2El.value;
  const rank = Number(addRankEl.value);
  const enh = Number(addEnhEl.value);
  const qty = Math.max(1, Number(addQtyEl.value||1));
  const spec = (kind==="double") ? {kind:"double", attrs:[a1,a2], rank, enh} : {kind:"single", attrs:[a1], rank, enh};
  if (spec.kind==="double" && (!a1 || !a2 || a1===a2)) return;
  const key = runeKey(spec);
  const found = state.inv.find(it => runeKey(it)===key);
  if (found){ found.qty = Number(found.qty||0) + qty; }
  else { state.inv.push({...spec, qty}); }
  buildInvTable();
  recalc();
});

// Inventory section toggle (only in æ‰‹æŒã¡éœŠéŸ»ã®ã¿ mode)
if (btnInvToggleEl && invSectionEl){
  btnInvToggleEl.addEventListener("click", ()=>{
    if (btnInvToggleEl.disabled) return;
    invSectionOpen = !invSectionOpen;
    invSectionEl.style.display = invSectionOpen ? "" : "none";
    updateInvToggleLabel();
  });
}

document.getElementById("btnResetAll").addEventListener("click", ()=>{
  if (!confirm("èŠ±å¾¡ãƒ»éœŠéŸ»ãƒ»åœ¨åº«ã‚’å…¨ãƒªã‚»ãƒƒãƒˆã™ã‚‹ï¼Ÿ")) return;
  state.flowers = Object.fromEntries(FLOWER_IDS.map(id=>[id,""]));
  state.flowerLv = Object.fromEntries(FLOWER_IDS.map(id=>[id,9]));
  state.runes = {};
  state.inv = [];
  if (runeSearchEl) runeSearchEl.value = "";
  buildInvTable();
  recalc();
});

document.getElementById("btnExport").addEventListener("click", exportJson);
document.getElementById("btnImport").addEventListener("click", importJson);

document.getElementById("btnClearRunes").addEventListener("click", ()=>{
  state.runes = {};
  recalc();
});
document.getElementById("btnClearFlowers").addEventListener("click", ()=>{
  state.flowers = Object.fromEntries(FLOWER_IDS.map(id=>[id,""]));
  state.flowerLv = Object.fromEntries(FLOWER_IDS.map(id=>[id,9]));
  recalc();
});

jobTypeEl.addEventListener("change", ()=>{ updateAddForm(); buildInvTable(); updateTopbar(); recalc(); });
if (modeSelEl) modeSelEl.addEventListener("change", ()=>{ syncModeUI(); updateTopbar(); recalc(); });
enforceInvEl.addEventListener("change", recalc);
if (runeSearchEl) runeSearchEl.addEventListener("input", ()=>{ recalc(); });
addKindEl.addEventListener("change", ()=>{ updateAddForm(); });
addA1El.addEventListener("change", ()=>{ updateAddForm(); });
function syncModeUI(){
  const invModeNow = (modeSelEl && modeSelEl.value === "inv");

  // æ‰‹æŒã¡éœŠéŸ»ã®ã¿ãƒ¢ãƒ¼ãƒ‰ï¼šã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ“ä½œã‚’æœ‰åŠ¹åŒ–
  if (btnInvToggleEl){
    btnInvToggleEl.disabled = !invModeNow;
  }
  if (invSectionEl){
    invSectionEl.style.display = invModeNow ? (invSectionOpen ? "" : "none") : "none";
  }

  // æ‰‹æŒã¡éœŠéŸ»ã®ã¿ãƒ¢ãƒ¼ãƒ‰ã§ã¯åœ¨åº«åˆ¶é™ã‚’å¸¸æ™‚ONï¼ˆUIã¯éè¡¨ç¤ºï¼‰
  if (enforceInvEl){
    enforceInvEl.checked = invModeNow ? true : false;
    enforceInvEl.disabled = invModeNow ? true : false;
  }
  if (enforceInvWrapEl){
    enforceInvWrapEl.style.display = "none";
  }

  // UIæ›´æ–°
  updateInvToggleLabel();
  updateRuneOptions();
  renderRemainTable();
}

function init(){
  // Theme toggle (saved in localStorage)
  try {
    const saved = localStorage.getItem('hanamiTheme');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initial = saved || (prefersDark ? 'dark' : 'light');
    if (initial === 'dark') document.documentElement.setAttribute('data-theme','dark');

    const refreshThemeLabel = () => {
      const isDarkNow = document.documentElement.getAttribute('data-theme') === 'dark';
      if (themeLabelEl) themeLabelEl.textContent = isDarkNow ? 'ãƒ€ãƒ¼ã‚¯' : 'ãƒ©ã‚¤ãƒˆ';
    };
    refreshThemeLabel();

    if (themeToggleEl){
      themeToggleEl.addEventListener('click', () => {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        if (isDark){
          document.documentElement.removeAttribute('data-theme');
          localStorage.setItem('hanamiTheme','light');
        } else {
          document.documentElement.setAttribute('data-theme','dark');
          localStorage.setItem('hanamiTheme','dark');
        }
        refreshThemeLabel();
      });
    }
  } catch(e){ /* ignore */ }

  // Costå‚è€ƒï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ï¼‰
  try {
    const btnCostRef = document.getElementById("btnCostRef");
    const costOverlay = document.getElementById("costOverlay");
    const btnCloseCost = document.getElementById("btnCloseCost");

    function openCostRef(){
      if (!costOverlay) return;
      costOverlay.classList.remove("hidden");
      costOverlay.setAttribute("aria-hidden","false");
    }
    function closeCostRef(){
      if (!costOverlay) return;
      costOverlay.classList.add("hidden");
      costOverlay.setAttribute("aria-hidden","true");
    }

    if (btnCostRef) btnCostRef.addEventListener("click", openCostRef);
    if (btnCloseCost) btnCloseCost.addEventListener("click", closeCostRef);

    if (costOverlay){
      costOverlay.addEventListener("click", (e)=>{ if (e.target === costOverlay) closeCostRef(); });
    }
    document.addEventListener("keydown", (e)=>{ if (e.key === "Escape") closeCostRef(); });
  } catch(e){ /* ignore */ }

  updateAddForm();
  buildInvTable();
  syncModeUI();
  recalc();

  // åˆæœŸæç”»ç›´å¾Œã¯æ¨ªå¹…ãŒ0ã«ãªã‚‹ç’°å¢ƒãŒã‚ã‚‹ã®ã§ã€1å›ã ã‘å†æç”»
  setTimeout(() => { try { recalc(); } catch(e){ console.error(e); } }, 0);
}

document.addEventListener('DOMContentLoaded', () => {
  try { init(); } catch(e){ console.error(e); }
});

window.addEventListener('load', () => {
  try { recalc(); } catch(e){ console.error(e); }
});

</script>

  <!-- Cost reference overlay -->
  <div id="costOverlay" class="overlay hidden" aria-hidden="true">
    <div class="drawerCard" role="dialog" aria-modal="true" aria-label="Costå‚è€ƒ">
      <div class="row" style="justify-content:space-between;">
        <span class="pill">Costå‚è€ƒ</span>
        <button id="btnCloseCost" type="button" class="btnGhost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="tableWrap" style="margin-top:10px;">
        <table>
          <thead>
            <tr><th>Rank</th><th>+7 Cost</th><th>+8 Cost</th><th>+9 Cost</th></tr>
          </thead>
          <tbody>
            <tr><td>Rank2</td><td>100</td><td>200</td><td>400</td></tr>
            <tr><td>Rank1</td><td>47</td><td>94</td><td>188</td></tr>
          </tbody>
        </table>
      </div>
      <div class="hint" style="margin-top:8px;">â€»å¿…è¦ã«å¿œã˜ã¦å‚ç…§ï¼ˆå¸¸æ™‚è¡¨ç¤ºã—ã¾ã›ã‚“ï¼‰</div>
    </div>
  </div>

</body>
</html>

  
